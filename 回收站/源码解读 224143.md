
# 1、基本的代码框架

## 1.1、STM32移植代码关系图

![系统代码关系图](image\系统代码关系图.jpg)

## 1.2、 V2.86 ucos-II 代码结构

***Source和 Port 是我们最为关心的地方***
![ucos代码结构小](image\ucos代码结构小.jpg)

# 2、main函数源码解读

> ucos-II仅仅是一个库，刚刚接手源代码，往往让人不知所以，根本不知道代码要从什么地方开始看，结果就是看得一头雾水，很快就放弃了。
>
> 我们从一个已经移植到STM32F103ZE系列单片机并且能够跑通的源代码的main函数还是分析。
>
> ```c
> //main函数的源代码
> #include "includes.h"
> OS_STK startup_task_stk[STARTUP_TASK_STK_SIZE];
> int main(void)
> {
>   	BSP_Init();
> 	OSInit();
> 	OSTaskCreate(Task_Start,(void *)0,
> 	   &startup_task_stk[STARTUP_TASK_STK_SIZE-1], STARTUP_TASK_PRIO);
> 
> 	OSStart();
>     return 0;
>  }
> ```
>
> 各个函数的大致功能如下
>
> * 硬件初始化：初始化硬件的驱动程序  board support package 板上支持包。初始化ADC引脚，定时器等
> * 操作系统初始化：创建系统任务，新建控制块链表
> * 创建用户任务：需要输入任务堆栈区，任务函数指针，优先级大小
> * 然后启动操作系统，开始任务的切换


## 2.1、BSP.c

![BSP1](image\BSP1.jpg)

程序是关于

* 外部设备的初始化
* 一些寄存器的操作API

* 设备中断服务程序

## 2.2、OS_Core.c

### void OSInit(void)

* 初始化中断嵌套计数器，任务数量，系统启动标志位false，任务上下文切换计数器，空闲计数器OSIdleCtr

* 初始化就绪任务表OSRdyTbl【OS_RDY_TBL_SIZE】和 就绪组int OSRdyGrp

* 初始化任务控制块OSTCBFreeList【OS_MAX_TASKS + OS_N_SYS_TASKS】

* 初始化事件OSEventFreeList【OS_MAX_EVENTS】

* 创建空闲任务 OS_TaskIdle


***OS_CFG.h中可配置项:***

* OS_FLAG_EN 初始化 OSFlagFreeList【OS_MAX_FLAGS】单向链表

* OS_MEM_EN 初始化内存管理 OSMemFreeList【OS_MAX_MEM_PART】单向链表

* OS_Q_EN 初始化空队列链表 OSQFreeList【OS_MAX_QS】单向链表

* OS_TASK_STAT_EN 创建统计任务 OS_TaskStat

* OS_TMR_EN 初始化 OSTmrFreeList【OS_TMR_CFG_MAX】单向链表

* OS_DEBUG_EN 允许调试信息



### void  OSStart (void)

OS_SchedNew()寻找最高优先级任务


OSStartHighRdy() 汇编函数，设置PendSV中断优先级，启动中断，进行第一次任务切换



### 其他重要函数

* OS_TASK_SW（）   : 调用汇编函数进行任务切换。
* OS_SchedNew()    :  寻找最高优先级任务
* OS_Sched()   ： 调用OS_SchedNew和OS_TASK_SW，如果当前任务为最高优先级任务，那么不任务切换，否则任务切换。在任务创建完成后会调用
* OSIntEnter   ： 全局变量OSIntNesting++，必须在进入中断服务中调用，你可以直接用OSIntNesting++替代
* OSIntExit     ： 全局变量OSIntNesting--， 同时调用OS_SchedNew()，OSIntCtxSw（），如果当前任务为最高优先级任务，那么不任务切换，否则任务切换。下图参考 【1】

![OS_InitExit](D:\10-UCOSII\分析ucos重要资料\image\OS_InitExit.jpg)

## 2.3、os_task.c

### OSTaskCreate（）

> 传入参数：
>
> void (*task)(void *p_arg)	——任务函数指针
>
> void *p_arg						——任务的传递参数
>
> OS_STK *ptos					——指向任务分配的堆栈空间指针
>
> INT8U prio						——任务优先级
>
> 功能：
>
> * 判断是否中断嵌套OSIntNesting > 0，返回错误信息
> * 判断该优先级是否已经存在于已有的任务中(OSTCBPrioTbl[prio] == (OS_TCB *)0, 如果存在那么这是一个有效的指向TCB的指针，不可能是null),返回错误信息
> * 随后，在不可中断的代码中实现堆栈初始化（OSTaskStkInit函数）
>
> ```c
> *(stk)    = (INT32U)0x01000000L;             /* xPSR  */
> *(--stk)  = (INT32U)task;                    /* Entry Point    */
> *(--stk)  = (INT32U)0xFFFFFFFEL;             /* R14 (LR) (init value will cause fault if ever used)*/
> *(--stk)  = (INT32U)0x12121212L;             /* R12   */
> *(--stk)  = (INT32U)0x03030303L;             /* R3    */
> *(--stk)  = (INT32U)0x02020202L;             /* R2     */
> *(--stk)  = (INT32U)0x01010101L;             /* R1     */
> *(--stk)  = (INT32U)p_arg;                   /* R0 : argument  
> 
> /* Remaining registers saved on process stack         */
> *(--stk)  = (INT32U)0x11111111L;             /* R11   */
> *(--stk)  = (INT32U)0x10101010L;             /* R10  */
> *(--stk)  = (INT32U)0x09090909L;             /* R9    */
> *(--stk)  = (INT32U)0x08080808L;             /* R8    */
> *(--stk)  = (INT32U)0x07070707L;             /* R7     */
> *(--stk)  = (INT32U)0x06060606L;             /* R6     */
> *(--stk)  = (INT32U)0x05050505L;             /* R5     */
> *(--stk)  = (INT32U)0x04040404L;             /* R4     */
> ```
>
> * 调用OS_TCBInit（）函数，在不可中断代码中，从OSInit中创建的OSTCBFreeList链表中获取一个空的TCB，填写内容
> * 在不可中断代码中，建立双向链表，OSTCBPrioTbl【prio】中存储指向TCB的指针
>
> ```c
> OSTCBPrioTbl[prio] = ptcb;
> ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
> ptcb->OSTCBPrev    = (OS_TCB *)0;
> if (OSTCBList != (OS_TCB *)0) {
>     OSTCBList->OSTCBPrev = ptcb;
> }
> OSTCBList               = ptcb;
> ```
>
> * 如果上两步出错（没有空的TCB了），在不可中断代码中将OSTCBPrioTbl【prio】置为TCB*NULL
> * 如果成功并且操作系统已经启动，立即进行操作系统调度OS_Sched()，任务切换，该函数调用OS_SchedNew（）寻找最高优先级任务，如果最高优先级任务与当前任务不同（新增加的任务优先级更高），那么OS_TASK_SW（）调用汇编函数进行任务切换。



## 2.7、ucosii.h

定义了结构体和宏

## 2.8、OS_CFG.H 

非常重要的系统配置文件，参考C/OS-II Configuration Manual 

# 3、系统节拍

> main函数分析完成后，CPU由操作系统接管。接下来要如何分析呢
>
> 我们知道，没有人的干预，操作系统操作很死板，只是一个大循环或者重复的过程，通过每隔一定时间重复进行任务切换，信号量判断等方式进行。所以我们必须找到系统的定时器和定时器中断程序，这是解读操作系统的关键所在。

我们在库中只能找到一个定时器函数，位于os_core.c文件中

uC/OS-II在每次响应定时中断时调用OSTimeTick()做了两件事情：

* 是给计数器OSTime加1;
* 是遍历任务控制块链表中的所有任务控制块，把各个 任务控制块中用来存放任务延时时限的OSTCBDly变量减1，并使该项为0，同时又不使被挂 起的任务进入就绪状态。



  	简单地说，函数OSTimeTick()的任务就是在每个时钟节拍了解每个任务的延时状态，使其中已经到了延时时限的非挂起任务进入就绪状态。

```c
void  OSTimeTick (void)
{
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0u
    BOOLEAN    step;
#endif
    
#if OS_CRITICAL_METHOD == 3u           /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0u;
#endif



#if OS_TIME_TICK_HOOK_EN > 0u
    OSTimeTickHook();                 /* Call user definable hook   扩展功能程序  */
#endif
    
#if OS_TIME_GET_SET_EN > 0u
    OS_ENTER_CRITICAL();              /* Update the 32-bit tick counter  */
    OSTime++;
    OS_EXIT_CRITICAL();
#endif
    
    if (OSRunning == OS_TRUE) {
#if OS_TICK_STEP_EN > 0u
        switch (OSTickStepState) {    /* Determine whether we need to process a tick  */
            case OS_TICK_STEP_DIS:    /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
                 break;

            case OS_TICK_STEP_WAIT:   /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;     /*     .. OSTickStepState to OS_TICK_STEP_ONCE */
                 break;

            case OS_TICK_STEP_ONCE:   /* Yes, process tick once and wait for next ... */
                 step = OS_TRUE;  	  /*  ... step command from uC/OS-View    */
                 OSTickStepState = OS_TICK_STEP_WAIT;
                 break;

            default:                  /* Invalid case, correct situation     */
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {       /* Return if waiting for step command  */
            return;
        }
#endif
        
        ptcb = OSTCBList;             /* Point at first TCB in TCB list    */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) { /* 搜索整个TCB双向链表*/
            OS_ENTER_CRITICAL();
            if (ptcb->OSTCBDly != 0u) {   /* No, Delayed or waiting for event with TO */
                ptcb->OSTCBDly--;        /* Decrement nbr of ticks to end of delay  */
                if (ptcb->OSTCBDly == 0u) { /* Check for timeout     */

                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
                        ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;  /* Yes,等待信号未满足要求 */
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;     /* Indicate PEND timeout    */
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;	/*等待信号满足,可以启动任务*/
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* 任务是否挂起*/
                        OSRdyGrp               |= ptcb->OSTCBBitY;    /* No,Make ready */
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;       /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
```

**那么另一个问题来了，操作系统是怎么调用这个函数的呢？**

文献【1】中提到，调用是在汇编程序的中断中实现，但是我们并没有找到相关的汇编代码。我们猜测是通过C语言设定定时器的中断实现的，所以我们在stm32的中断服务程序种查找，发现果不其然，在stm32f10x_it.c中的中断服务函数如下：

```c
void SysTick_Handler(void)
{
    OSIntEnter(); 
    OSTimeTick(); 		//调用上述函数
    OSIntExit(); 
}
```

**最后，不要忘记了，既然存在定时器中断，那么定时周期是多少，在哪里修改和初始化的呢？**

在BSP.c,关于硬件的这部分程序中，我们找到了如下初始化代码

```c
void BSP_Init(void)
{
    SystemInit();		/* 配置系统时钟为72M */	
	SysTick_init();		/* 初始化并使能SysTick定时器 */
    GPIO_Config();  	/* 端口初始化 */
	USART1_Config();	/* 串口初始化 */
}
```

```c
/*
 * 函数名：SysTick_init
 * 描述  ：配置SysTick定时器
 * 输入  ：无
 * 输出  ：无
 */
void SysTick_init(void)
{
    SysTick_Config(SystemFrequency/OS_TICKS_PER_SEC);		//初始化并使能SysTick定时器
}
```

其中OS_TICKS_PER_SEC = 1000；实现每秒定时器中断1000次。

SysTick_Config函数在\CMSIS\core_cm3.h中实现，这是KEIL编译器自己提供的函数库

这样，整个操作系统的运作流程就打通了。



实际上，操作系统实际的时钟节拍是在os_cpu_c.c中OS_CPU_SysTickHandler() 【中断服务函数】,OS_CPU_SysTickInit()【中断初始化】这两个函数实现的。但是这两个函数基本都是通过修改寄存器来实现功能的，比较复杂，而且官方是采用IAR编译平台的，有些底层的函数无法调用，所以野火采用Keil自带的函数去实现，这里该段函数被设置为不编译。

![操作系统的运作流程](image\操作系统的运作流程.png)



# 4、汇编语言解读

> 汇编语言一般用于处理C语言无法完成的任务。譬如涉及中断，寄存器的操作，就必须要用汇编语言了



## 基本知识

[**单片机在调用子程序时，进行了怎样的堆栈操作？**](<http://www.elecfans.com/emb/xitong/20171116580315.html>)

　　栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

　　当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

　　堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

[**函数调用栈空间**](<https://blog.csdn.net/beyond702/article/details/52228683>)

​	在ARM指令系统中是地址递减栈，入栈操作的参数入栈顺序是从右到左依次入栈，而参数的出栈顺序则是从左到右的你操作。包括push/pop和LDMFD/STMFD等。比如指令 push {fp, sp, lr, pc}执行的结果就是图1中栈的样子，pc被首先入栈存在高地址，从右到左依次入栈，fp存在低地址。

[**与函数栈有关的寄存器**](<https://www.cnblogs.com/chyl411/p/4579053.html>)

* r15 PC The Program Counter.

* r14 LR The Link Register.

* r13 SP The Stack Pointer.

* r12 IP The Intra-Procedure-call scratch register. （可简单的认为暂存SP）

* r11是optional的，被称为FP，即frame pointer。



[**stack frame**](<https://blog.csdn.net/beyond702/article/details/52228683>)

​	stack我们都知道，每一个进程都有自己的栈。考虑进程执行时发生函数调用的场景，母函数和子函数使用的是同一个栈，在通常的情况下，我们并不需要区分母函数和子函数分别使用了栈的哪个部分。但是，当我们需要在执行过程中对函数调用进行backtrace(回溯)的时候，这一信息就很重要了。

​	简单的说，stack frame就是一个函数所使用的stack的一部分，所有函数的stack frame串起来就组成了一个完整的栈。stack frame的两个边界分别由FP和SP来限定。

**backtrace**

​	在程序执行过程中（通常是发生了某种意外情况而需要进行调试），通过SP和FP所限定的stack frame，就可以得到母函数的SP和FP，从而得到母函数的stack frame（PC，LR，SP，FP会在函数调用的第一时间压栈），以此追溯，即可得到所有函数的调用顺序。

![函数栈](image\函数栈.png)

​	ARM压栈的顺序很是规矩，依次为当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、*传入参数个数及指针、*本地变量(在该函数所在域的变量)和临时变量(编译器临时产生的变量)。如果函数准备调用另一个函数，跳转之前临时变量区（R0-R3）先要保存另一个函数的参数。

```c
int func(int a, int b, int c, int d)
{
	return 1;
}

int main()
{
	int i = 1, j = 2;
	func(i, j, 3, 4);
	return 0;
}
```

其对应的栈示意图如图：

![函数栈2](image\函数栈2.png)

***注意***：需要注意的是，这种压栈的方式，并不是cortex-M3单片机自动完成的，而是类似于某种约定或者标准，或者协议方便backtrace调试。

## [PendSV中断服务程序](<http://blog.chinaunix.net/uid-22072065-id-5770131.html>)

用于上下文切换

```scheme
OS_CPU_PendSVHandler
    CPSID   I                                    ; 屏蔽除NMI和硬fault中断，
    MRS     R0, PSP                              ; 读取进程SP
    CBZ     R0, OS_CPU_PendSVHandler_nosave      ; 如果为零(第一次切换任务)，不需要保存现场
    SUBS    R0, R0, #0x20                        ; 保存R4-R11,R0为栈顶
    STM     R0, {R4-R11}						 ; STM默认自增，所以上位需要腾出空间，R0不变

    LDR     R1, =OSTCBCur                        ; 【】相当于C语言的*
    LDR     R1, [R1]							 ; 获取当前任务块指针，第一个为堆栈指针地址
    STR     R0, [R1]                             ; 修改前任务块指针指向的第一个单元即SPP，至此现场保存完毕


; 调用用户钩子函数
; 获取最高优先级的就绪任务，获取任务的堆栈到R0
; 从堆栈读取数据到R4-R11，恢复现场
; 返回。
OS_CPU_PendSVHandler_nosave
    PUSH    {R14}                                               ; Save LR exc_return value
    LDR     R0, =OSTaskSwHook                                   ; 调用OSTaskSwHook();
    BLX     R0
    POP     {R14}

    LDR     R0, =OSPrioCur           ; 设置当前优先级为最高就绪优先级，OSPrioCur=OSPrioHighRdy;
    LDR     R1, =OSPrioHighRdy
    LDRB    R2, [R1]
    STRB    R2, [R0]

    LDR     R0, =OSTCBCur            ; 设置当前最高就绪的任务，OSTCBCur  = OSTCBHighRdy;
    LDR     R1, =OSTCBHighRdy
    LDR     R2, [R1]
    STR     R2, [R0]

    LDR     R0, [R2]                 ; SP=OSTCBHighRdy->OSTCBStkPtr;因为定义的结构第一个成员就是指向堆栈的指针
    LDM     R0, {R4-R11}             ; 从堆栈中读取数据到R4-R11。R0没有发生改变，权威手册P61
    ADDS    R0, R0, #0x20			 ; 堆栈是四个字节对齐的，所以此处SP相当于挪动8个存储单元，
    MSR     PSP, R0                  ; Load PSP with new process SP
    ORR     LR, LR, #0x04            ; 确保返回后使用的是PSP cortex-M3权威手册P139
    CPSIE   I
    BX      LR                       ; 中断返回会自动恢复剩余的一半寄存器，CP，PSR,RL

    END

```

## OSCtxSw/OSIntCtxSw

发起一个PendSV的中断，进行上下文切换



## OSStartHighRdy

在操作系统第一次上下文切换时，由OSStart()调用

* 设置PendSV中断的优先级
* 初始化用户进程堆栈
* 设置OSRunning系统启动标志位
* 触发一次中断

```scheme
OSStartHighRdy
    LDR     R0, =NVIC_SYSPRI14                                  ; Set the PendSV exception priority，设置优先级最高
    LDR     R1, =NVIC_PENDSV_PRI
    STRB    R1, [R0]

    MOVS    R0, #0                                              ; Set the PSP to 0 for initial context switch call 设置进程堆栈为0
    MSR     PSP, R0

    LDR     R0, =OSRunning                                      ; OSRunning = TRUE 系统启动
    MOVS    R1, #1
    STRB    R1, [R0]

    LDR     R0, =NVIC_INT_CTRL                                  ; 触发中断，Trigger the PendSV exception (causes context switch)
    LDR     R1, =NVIC_PENDSVSET
    STR     R1, [R0]

    CPSIE   I                                                   ; Enable interrupts at processor level，进入PENDSV中断

OSStartHang
    B       OSStartHang
```



## 不可中断代码段

> 用于不可中断代码，前后的中断屏蔽或者中断允许设置
>
> OS_CRITICAL_METHOD == 3时调用的函数，
>
> OS_ENTER_CRITICAL调用OS_CPU_SR_Save函数，并用cpu_sr变量保存返回值(返回值位于R0)
>
> OS_EXIT_CRITICAL调用OS_CPU_SR_Restore函数，并传入cpu_sr用于恢复

```scheme
; 注意，R0用于存储CPU的psr寄存器。 R0是restore函数传入的参数，R0也是save函数中return的参数，
OS_CPU_SR_Save					; Set prio int mask to mask all (except faults) PRIMASK 
    MRS     R0, PRIMASK         ; 保存进入不可中断代码之前的标志位
    CPSID   I					; 关中断，详见cortex M3 权威指南P42
    BX      LR

OS_CPU_SR_Restore				; 恢复不可中断代码之前的PRIMASK标志位
    MSR     PRIMASK, R0
    BX      LR
```





# 参考资料

【1】嵌入式实时操作系统ucos-II 原理及应用  任哲编著