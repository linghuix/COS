
# 1、基本的代码框架

## 1.1、STM32移植代码关系图

![系统代码关系图](image\系统代码关系图.jpg)

## 1.2、 V2.86 ucos-II 代码结构

***Source和 Port 是我们最为关心的地方***
![ucos代码结构小](image\ucos代码结构小.jpg)

# 2、main函数源码解读

> ucos-II仅仅是一个库，刚刚接手源代码，往往让人不知所以，根本不知道代码要从什么地方开始看，结果就是看得一头雾水，很快就放弃了。
>
> 我们从一个已经移植到STM32F103ZE系列单片机并且能够跑通的源代码的main函数还是分析。
>
> ```c
> //main函数的源代码
> #include "includes.h"
> OS_STK startup_task_stk[STARTUP_TASK_STK_SIZE];
> int main(void)
> {
>   	BSP_Init();
> 	OSInit();
> 	OSTaskCreate(Task_Start,(void *)0,
> 	   &startup_task_stk[STARTUP_TASK_STK_SIZE-1], STARTUP_TASK_PRIO);
> 
> 	OSStart();
>     return 0;
>  }
> ```
>
> 各个函数的大致功能如下
>
> * 硬件初始化：初始化硬件的驱动程序  board support package 板上支持包。初始化ADC引脚，定时器等
> * 操作系统初始化：创建系统任务，新建控制块链表
> * 创建用户任务：需要输入任务堆栈区，任务函数指针，优先级大小
> * 然后启动操作系统，开始任务的切换


## 2.1、BSP.c

![BSP1](image\BSP1.jpg)

程序是关于

* 外部设备的初始化
* 一些寄存器的操作API

* 设备中断服务程序

## 2.2、OS_Core.c

### void OSInit(void)

* 初始化中断嵌套计数器，任务数量，系统启动标志位false，任务上下文切换计数器，空闲计数器OSIdleCtr

* 初始化就绪任务表OSRdyTbl【OS_RDY_TBL_SIZE】和 就绪组int OSRdyGrp

* 初始化任务控制块OSTCBFreeList【OS_MAX_TASKS + OS_N_SYS_TASKS】

* 初始化事件OSEventFreeList【OS_MAX_EVENTS】

* 创建空闲任务 OS_TaskIdle


***OS_CFG.h中可配置项:***

* OS_FLAG_EN 初始化 OSFlagFreeList【OS_MAX_FLAGS】单向链表

* OS_MEM_EN 初始化内存管理 OSMemFreeList【OS_MAX_MEM_PART】单向链表

* OS_Q_EN 初始化空队列链表 OSQFreeList【OS_MAX_QS】单向链表

* OS_TASK_STAT_EN 创建统计任务 OS_TaskStat

* OS_TMR_EN 初始化 OSTmrFreeList【OS_TMR_CFG_MAX】单向链表

* OS_DEBUG_EN 允许调试信息



### void  OSStart (void)

OS_SchedNew()寻找最高优先级任务


OSStartHighRdy() 汇编函数，设置PendSV中断优先级，启动中断，进行第一次任务切换



### 其他重要函数

* OS_TASK_SW（）   : 调用汇编函数进行任务切换。
* OS_SchedNew()    :  寻找最高优先级任务
* OS_Sched()   ： 调用OS_SchedNew和OS_TASK_SW，如果当前任务为最高优先级任务，那么不任务切换，否则任务切换。在任务创建完成后会调用
* OSIntEnter   ： 全局变量OSIntNesting++，必须在进入中断服务中调用，你可以直接用OSIntNesting++替代
* OSIntExit     ： 全局变量OSIntNesting--， 同时调用OS_SchedNew()，OSIntCtxSw（），如果当前任务为最高优先级任务，那么不任务切换，否则任务切换。下图参考 【1】

![OS_InitExit](D:\10-UCOSII\分析ucos重要资料\image\OS_InitExit.jpg)

## 2.3、os_task.c

### OSTaskCreate（）

> 传入参数：
>
> void (*task)(void *p_arg)	――任务函数指针
>
> void *p_arg						――任务的传递参数
>
> OS_STK *ptos					――指向任务分配的堆栈空间指针
>
> INT8U prio						――任务优先级
>
> 功能：
>
> * 判断是否中断嵌套OSIntNesting > 0，返回错误信息
> * 判断该优先级是否已经存在于已有的任务中(OSTCBPrioTbl[prio] == (OS_TCB *)0, 如果存在那么这是一个有效的指向TCB的指针，不可能是null),返回错误信息
> * 随后，在不可中断的代码中实现堆栈初始化（OSTaskStkInit函数）
>
> ```c
> *(stk)    = (INT32U)0x01000000L;             /* xPSR  */
> *(--stk)  = (INT32U)task;                    /* Entry Point    */
> *(--stk)  = (INT32U)0xFFFFFFFEL;             /* R14 (LR) (init value will cause fault if ever used)*/
> *(--stk)  = (INT32U)0x12121212L;             /* R12   */
> *(--stk)  = (INT32U)0x03030303L;             /* R3    */
> *(--stk)  = (INT32U)0x02020202L;             /* R2     */
> *(--stk)  = (INT32U)0x01010101L;             /* R1     */
> *(--stk)  = (INT32U)p_arg;                   /* R0 : argument  
> 
> /* Remaining registers saved on process stack         */
> *(--stk)  = (INT32U)0x11111111L;             /* R11   */
> *(--stk)  = (INT32U)0x10101010L;             /* R10  */
> *(--stk)  = (INT32U)0x09090909L;             /* R9    */
> *(--stk)  = (INT32U)0x08080808L;             /* R8    */
> *(--stk)  = (INT32U)0x07070707L;             /* R7     */
> *(--stk)  = (INT32U)0x06060606L;             /* R6     */
> *(--stk)  = (INT32U)0x05050505L;             /* R5     */
> *(--stk)  = (INT32U)0x04040404L;             /* R4     */
> ```
>
> * 调用OS_TCBInit（）函数，在不可中断代码中，从OSInit中创建的OSTCBFreeList链表中获取一个空的TCB，填写内容
> * 在不可中断代码中，建立双向链表，OSTCBPrioTbl【prio】中存储指向TCB的指针
>
> ```c
> OSTCBPrioTbl[prio] = ptcb;
> ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
> ptcb->OSTCBPrev    = (OS_TCB *)0;
> if (OSTCBList != (OS_TCB *)0) {
>     OSTCBList->OSTCBPrev = ptcb;
> }
> OSTCBList               = ptcb;
> ```
>
> * 如果上两步出错（没有空的TCB了），在不可中断代码中将OSTCBPrioTbl【prio】置为TCB*NULL
> * 如果成功并且操作系统已经启动，立即进行操作系统调度OS_Sched()，任务切换，该函数调用OS_SchedNew（）寻找最高优先级任务，如果最高优先级任务与当前任务不同（新增加的任务优先级更高），那么OS_TASK_SW（）调用汇编函数进行任务切换。



## 2.7、ucosii.h

定义了结构体和宏

## 2.8、OS_CFG.H 

非常重要的系统配置文件，参考C/OS-II Configuration Manual 

# 3、系统节拍

> main函数分析完成后，CPU由操作系统接管。接下来要如何分析呢
>
> 我们知道，没有人的干预，操作系统操作很死板，只是一个大循环或者重复的过程，通过每隔一定时间重复进行任务切换，信号量判断等方式进行。所以我们必须找到系统的定时器和定时器中断程序，这是解读操作系统的关键所在。

我们在库中只能找到一个定时器函数，位于os_core.c文件中

uC/OS-II在每次响应定时中断时调用OSTimeTick()做了两件事情：

* 是给计数器OSTime加1;
* 是遍历任务控制块链表中的所有任务控制块，把各个 任务控制块中用来存放任务延时时限的OSTCBDly变量减1，并使该项为0，同时又不使被挂 起的任务进入就绪状态。



  	简单地说，函数OSTimeTick()的任务就是在每个时钟节拍了解每个任务的延时状态，使其中已经到了延时时限的非挂起任务进入就绪状态。

```c
void  OSTimeTick (void)
{
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0u
    BOOLEAN    step;
#endif
    
#if OS_CRITICAL_METHOD == 3u           /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0u;
#endif



#if OS_TIME_TICK_HOOK_EN > 0u
    OSTimeTickHook();                 /* Call user definable hook   扩展功能程序  */
#endif
    
#if OS_TIME_GET_SET_EN > 0u
    OS_ENTER_CRITICAL();              /* Update the 32-bit tick counter  */
    OSTime++;
    OS_EXIT_CRITICAL();
#endif
    
    if (OSRunning == OS_TRUE) {
#if OS_TICK_STEP_EN > 0u
        switch (OSTickStepState) {    /* Determine whether we need to process a tick  */
            case OS_TICK_STEP_DIS:    /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
                 break;

            case OS_TICK_STEP_WAIT:   /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;     /*     .. OSTickStepState to OS_TICK_STEP_ONCE */
                 break;

            case OS_TICK_STEP_ONCE:   /* Yes, process tick once and wait for next ... */
                 step = OS_TRUE;  	  /*  ... step command from uC/OS-View    */
                 OSTickStepState = OS_TICK_STEP_WAIT;
                 break;

            default:                  /* Invalid case, correct situation     */
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {       /* Return if waiting for step command  */
            return;
        }
#endif
        
        ptcb = OSTCBList;             /* Point at first TCB in TCB list    */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) { /* 搜索整个TCB双向链表*/
            OS_ENTER_CRITICAL();
            if (ptcb->OSTCBDly != 0u) {   /* No, Delayed or waiting for event with TO */
                ptcb->OSTCBDly--;        /* Decrement nbr of ticks to end of delay  */
                if (ptcb->OSTCBDly == 0u) { /* Check for timeout     */

                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
                        ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;  /* Yes,等待信号未满足要求 */
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;     /* Indicate PEND timeout    */
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;	/*等待信号满足,可以启动任务*/
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* 任务是否挂起*/
                        OSRdyGrp               |= ptcb->OSTCBBitY;    /* No,Make ready */
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;       /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
```

**那么另一个问题来了，操作系统是怎么调用这个函数的呢？**

文献【1】中提到，调用是在汇编程序的中断中实现，但是我们并没有找到相关的汇编代码。我们猜测是通过C语言设定定时器的中断实现的，所以我们在stm32的中断服务程序种查找，发现果不其然，在stm32f10x_it.c中的中断服务函数如下：

```c
void SysTick_Handler(void)
{
    OSIntEnter(); 
    OSTimeTick(); 		//调用上述函数
    OSIntExit(); 
}
```

**最后，不要忘记了，既然存在定时器中断，那么定时周期是多少，在哪里修改和初始化的呢？**

在BSP.c,关于硬件的这部分程序中，我们找到了如下初始化代码

```c
void BSP_Init(void)
{
    SystemInit();		/* 配置系统时钟为72M */	
	SysTick_init();		/* 初始化并使能SysTick定时器 */
    GPIO_Config();  	/* 端口初始化 */
	USART1_Config();	/* 串口初始化 */
}
```

```c
/*
 * 函数名：SysTick_init
 * 描述  ：配置SysTick定时器
 * 输入  ：无
 * 输出  ：无
 */
void SysTick_init(void)
{
    SysTick_Config(SystemFrequency/OS_TICKS_PER_SEC);		//初始化并使能SysTick定时器
}
```

其中OS_TICKS_PER_SEC = 1000；实现每秒定时器中断1000次。

SysTick_Config函数在\CMSIS\core_cm3.h中实现，这是KEIL编译器自己提供的函数库

这样，整个操作系统的运作流程就打通了。



实际上，操作系统实际的时钟节拍是在os_cpu_c.c中OS_CPU_SysTickHandler() 【中断服务函数】,OS_CPU_SysTickInit()【中断初始化】这两个函数实现的。但是这两个函数基本都是通过修改寄存器来实现功能的，比较复杂，而且官方是采用IAR编译平台的，有些底层的函数无法调用，所以野火采用Keil自带的函数去实现，这里该段函数被设置为不编译。



![操作系统的运作流程](image\操作系统的运作流程.png)


