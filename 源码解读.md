[TOC]



# 1、基本的代码框架

## 1.1、STM32移植代码关系图

![系统代码关系图](image\系统代码关系图.jpg)

## 1.2、 V2.86 ucos-II 代码结构

***Source和 Port 是我们最为关心的地方***
![ucos代码结构小](image\ucos代码结构小.jpg)

# 2、main函数源码解读

前言：每一个函数只是介绍其基本的内容和功能，具体参数请参考官网源码中的注释，很详细的

> ucos-II仅仅是一个库，刚刚接手源代码，往往让人不知所以，根本不知道代码要从什么地方开始看，结果就是看得一头雾水，很快就放弃了。
>
> 我们从一个已经移植到STM32F103ZE系列单片机并且能够跑通的源代码的main函数还是分析。
>
> ```c
> //main函数的源代码
> #include "includes.h"
> OS_STK startup_task_stk[STARTUP_TASK_STK_SIZE];
> int main(void)
> {
>   	BSP_Init();
> 	OSInit();
> 	OSTaskCreate(Task_Start,(void *)0,
> 	   &startup_task_stk[STARTUP_TASK_STK_SIZE-1], STARTUP_TASK_PRIO);
> 
> 	OSStart();
>     return 0;
>  }
> ```
>
> 各个函数的大致功能如下
>
> * 硬件初始化：初始化硬件的驱动程序  board support package 板上支持包。初始化ADC引脚，定时器等
> * 操作系统初始化：创建系统任务，新建控制块链表
> * 创建用户任务：需要输入任务堆栈区，任务函数指针，优先级大小
> * 然后启动操作系统，开始任务的切换


## 2.1、BSP.c

![BSP1](image\BSP1.jpg)

程序是关于

* 外部设备的初始化
* 一些寄存器的操作API

* 设备中断服务程序

## 2.2、OS_Core.c

### void OSInit(void)

> void  OSInit (void)
>
> 只介绍基本功能

* 调用***OSInitHookBegin*** ，用户自定义宏
* 调用***OS_InitMisc*** 初始化中断嵌套计数器，任务计数器，系统启动标志位false，任务上下文切换计数器，空闲计数器OSIdleCtr清零
* ***OS_InitRdyList*** 初始化就绪任务表OSRdyTbl【OS_RDY_TBL_SIZE】和 就绪组int OSRdyGrp
* ***OS_InitTCBList*** 初始化任务控制块OSTCBFreeList【OS_MAX_TASKS + OS_N_SYS_TASKS】
* ***OS_InitEventList*** 初始化事件OSEventFreeList【OS_MAX_EVENTS】
* ***OS_InitTaskIdle*** 创建空闲任务 OS_TaskIdle



### OS_InitEventList/OS_InitTCBList/OS_InitRdyList

* 调用***OS_MemClr*** 清零内存
* 建立OSEVENT的单向链表

OS_InitMisc



### OS_InitTaskIdle

建立任务系统空闲任务Idle

### OS_TaskIdle

* OSIdleCtr++
* 调用OSTaskIdleHook

### **OS_MemClr

> void  OS_MemClr (INT8U  *pdest,  INT16U  size)

```c
while (size > 0u) {
    *pdest++ = (INT8U)0;
    size--;
}
```
### OS_MemCopy 

> void  OS_MemCopy (INT8U  *pdest,  INT8U  *psrc,  INT16U  size)

将psrc内容拷贝到pdest中



### void  OSStart (void)

***OS_SchedNew()*** 寻找最高优先级任务
设置 当前运行任务优先级，最高就绪优先级任务，当前运行任务
***OSStartHighRdy()*** 汇编函数，设置PendSV中断优先级，启动中断，进行第一次任务切换


### OSIntEnter

全局变量OSIntNesting++，必须在进入中断服务中调用，你可以直接用OSIntNesting++替代

### OSIntExit 
**中断级任务调度**。全局变量OSIntNesting--， 同时调用OS_SchedNew()，OSIntCtxSw（）[汇编]，如果当前任务为最高优先级任务，那么不任务切换，否则任务切换。下图参考 【1】

![OS_InitExit](image\OS_InitExit.jpg)


### OSTimeTick

扫描整个任务，延迟减一，如果变成零了，那么等待结束标志位超时，并使任务就绪。(如果任务suspend ，则任务持续等待)【一个任务可以实现suspend的同时等待其他事件，应为suspend可以是其他任务调用来控制另一个处于等待事件的任务的】



### OSVersion

返回操作系统版本号



### OS_TCBInit

> INT8U  OS_TCBInit (INT8U    prio,
>                    OS_STK  *ptos,
>                    OS_STK  *pbos,
>                    INT16U   id,
>                    INT32U   stk_size,
>                    void    *pext,
>                    INT16U   opt)

TCB的初始化

由***OSTaskCreate*** 调用,设置TCB的优先级，栈顶指针，【栈底指针，任务的ID，栈空间大小，用户提供的内存区用来自定义任务的其他属性，opt】（只用于***OSTaskCreateExt**）


### OS_Sched() 

**任务级任务调度**

调用OS_SchedNew获取就绪表中最高优先级任务，如果当前任务与最高优先级任务不相同，那么调用OS_TASK_SW 任务切换，否则不进行切换。



该函数一般，在任务创建完成后会调用



### OS_SchedNew() 

通过就绪表，快速寻找最高优先级，将最高优先级存储于全局变量OSPrioHighRdy




### OS_EventTaskRdy

INT8U  OS_EventTaskRdy (OS_EVENT  *pevent, void *pmsg, INT8U msk, INT8U pend_stat)

> OS_EVENT_EN,OS_EVENT_MULTI_EN,OS_Q_EN,OS_MAX_QS,OS_MBOX_EN
>
> 强制最高等待任务进入就绪表

- 查找等待列表中最高的优先级
- 接收pmsg消息指针，设置OSTCBStat任务状态，OSTCBStatPend请求结果状态
- 如果任务在等待信号量，那么延迟置零同时删除等待信号量状态
- 如果在等待邮箱，将pmsg传给任务，并删除等待邮箱状态
- 如果在等待信号集，调用OS_EventTaskRemoveMulti
- 如果任务没有挂起，在就绪表中登记
- 调用OS_EventTaskRemove从等待列表中删除任务
- 返回最高的优先级

### OS_EventTaskWait

> OS_EVENT_EN
>
> void  OS_EventTaskWait (OS_EVENT *pevent)

- 将当前任务加入等待列表，
- 设置属性OSTCBCur->OSTCBEventPtr，保存等待任务的等待事件(一种任务在等待时只能等一种事件)
- 从就绪表中注销，

### OS_EventTaskRemove

> void  OS_EventTaskRemove (OS_TCB   *ptcb,  OS_EVENT *pevent)

Remove task from wait list

### OS_EventTaskRemoveMulti 未看



### 其他重要函数

* OS_TASK_SW（）   : 调用汇编函数进行任务切换。
* OSSchedLock：上锁调度器，上锁过程，无法实现任务调度。OSLockNesting++
* OSSchedUnlock：解锁调度器,OSLockNesting--
* OS_StrLen：返回传入字符的长度
* OS_EventWaitListInit (OS_EVENT *pevent)：初始化事件的OSEventGrp，OSEventTbl为0



可裁剪功能

### OSEventNameGet 

> (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
>
> INT8U  OSEventNameGet (OS_EVENT   *pevent,  INT8U  **pname, INT8U *perr)

* 获取时间的名称 \*pname = pevent->OSEventName 

* 返回名字的长度



### OSEventNameSet

> (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)

设置事件名称pevent->OSEventName = pname;



### OSEventPendMulti

> 等待多个事件，其中一个可用就会返回，如果一个都不可用，挂起，知道其中一个可用。返回可用的事件数量。无法在中断中调用
>
> ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
>
> INT16U  OSEventPendMulti (OS_EVENT  \*\*pevents_pend,
>                        OS_EVENT  \*\*pevents_rdy,
>                        void      \*\*pmsgs_rdy,
>                        INT32U      timeout,
>                        INT8U      \*perr)
>
> pevents_pend 等待时间的数组，以null结尾 (在while中判断结尾)
>
> pevents_rdy 返回那些时间就绪的数组，以null结尾，需要等于或者大于 pevents_pend 
>
> pmsgs_rdy返回的pevents_rdy事件对应的消息，不以null结尾，

该函数只能请求OS_EVENT_TYPE_SEM，OS_EVENT_TYPE_MBOX，OS_EVENT_TYPE_Q这三个事件

* 循环pevents_pend 中的事件
* 如果事件可用，那么将事件指针存储于pevents_rdy ，并且如果是通讯事件，那么将message存储于pmsgs_rdy，不是的话存储null。
* 如果时间不可用，那么记录该事件类型
* 退出循环
  * 如果有一个资源可用，就可以返回可用资源数，不需要挂起
  * 如果一个都不可用，那么改变任务状态，进入等待列表，任务调度
* 调度回来后，根据请求结束标记

> note:OSSemPendAbort，在该函数中，被禁止的任务如果正在等待多事件，那么会将这个事件赋值给任务控制块中的OSTCBEventPtr属性。

* 一个switch 将请求到的事件存储于pevents_rdy 
* 另一个switch 将请求到的事件的消息存储于pmsgs_rdy



### OS_EventTaskWaitMulti

> void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,  OS_EVENT **pevents_multi)

将任务注册于pevents_multi指向的所有事件中。



### OS_EventTaskRemoveMulti 

>  void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb, OS_EVENT **pevents_multi)
>
> 调用于 Q，MBOX，MUTEX，SEM 这些事件的POST函数中，只要多事件中的一个就绪了，就调用这个函数，实现挂起的返回

将任务从pevents_multi指向的所有事件中移除。

## 2.3、os_task.c

### OSTaskCreate

不允许在中断服务程序中使用.

> 传入参数：
>
> void (*task)(void *p_arg)	——任务函数指针
>
> void *p_arg						——任务的传递参数
>
> OS_STK *ptos					——指向任务分配的堆栈空间指针
>
> INT8U prio						——任务优先级
>
> 功能：
>
> * 判断是否中断嵌套OSIntNesting > 0，返回错误信息
> * 判断该优先级是否已经存在于已有的任务中(OSTCBPrioTbl[prio] == (OS_TCB *)0, 如果存在那么这是一个有效的指向TCB的指针，不可能是null),返回错误信息
> * 随后，在不可中断的代码中实现堆栈初始化（OSTaskStkInit函数）
>
> ```c
> *(stk)    = (INT32U)0x01000000L;             /* xPSR  */
> *(--stk)  = (INT32U)task;                    /* Entry Point    */
> *(--stk)  = (INT32U)0xFFFFFFFEL;             /* R14 (LR) (init value will cause fault if ever used)*/
> *(--stk)  = (INT32U)0x12121212L;             /* R12   */
> *(--stk)  = (INT32U)0x03030303L;             /* R3    */
> *(--stk)  = (INT32U)0x02020202L;             /* R2     */
> *(--stk)  = (INT32U)0x01010101L;             /* R1     */
> *(--stk)  = (INT32U)p_arg;                   /* R0 : argument  
> 
> /* Remaining registers saved on process stack         */
> *(--stk)  = (INT32U)0x11111111L;             /* R11   */
> *(--stk)  = (INT32U)0x10101010L;             /* R10  */
> *(--stk)  = (INT32U)0x09090909L;             /* R9    */
> *(--stk)  = (INT32U)0x08080808L;             /* R8    */
> *(--stk)  = (INT32U)0x07070707L;             /* R7     */
> *(--stk)  = (INT32U)0x06060606L;             /* R6     */
> *(--stk)  = (INT32U)0x05050505L;             /* R5     */
> *(--stk)  = (INT32U)0x04040404L;             /* R4     */
> ```
>
> * 调用OS_TCBInit（）函数，在不可中断代码中，从OSInit中创建的OSTCBFreeList链表中获取一个空的TCB，填写内容
> * 在不可中断代码中，建立双向链表，OSTCBPrioTbl【prio】中存储指向TCB的指针
>
> ```c
> OSTCBPrioTbl[prio] = ptcb;
> ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
> ptcb->OSTCBPrev    = (OS_TCB *)0;
> if (OSTCBList != (OS_TCB *)0) {
>     OSTCBList->OSTCBPrev = ptcb;
> }
> OSTCBList               = ptcb;
> ```
>
> * 如果上两步出错（没有空的TCB了），在不可中断代码中将OSTCBPrioTbl【prio】置为TCB*NULL
> * 如果成功并且操作系统已经启动，立即进行操作系统调度OS_Sched()，任务切换，该函数调用OS_SchedNew（）寻找最高优先级任务，如果最高优先级任务与当前任务不同（新增加的任务优先级更高），那么OS_TASK_SW（）调用汇编函数进行任务切换。



### OSTaskSuspend 

INT8U  OSTaskSuspend (INT8U prio)

> 相关宏：OS_TASK_SUSPEND_EN，OS_CRITICAL_METHOD，OS_ARG_CHK_EN

**ptcb->OSTCBStat**  设置为  **挂起任务标志** OS_STAT_SUSPEND（实际挂起操作位于节拍函数中），注销就绪表，如果挂起的是自己执行一次调度

该函数可以挂起自己，此时必须使用OS_PRIO _SELF(0XFF)。**挂起本身时，需要进行一次任务的调度**



### OSTaskResume 

> INT8U  OSTaskResume (INT8U prio)

>相关宏：OS_TASK_SUSPEND_EN，OS_CRITICAL_METHOD，OS_ARG_CHK_EN

**ptcb->OSTCBStat**  取消  **挂起任务标志** ，登记就绪表 ，并执行调度

取消任务挂起，（实际挂起操作位于节拍函数中）



### OSTaskChangePrio-未搞懂

INT8U  OSTaskChangePrio (INT8U  oldprio, INT8U  newprio)

> OS_CRITICAL_METHOD, OS_ARG_CHK_EN, OS_EVENT_EN, OS_EVENT_MULTI_EN

判断newprio是否存在，oldprio任务是否存在或者被占用OS_TCB_RESERVED，返回相应的异常。

然后，注销旧的优先级的就绪表(如果任务处于就绪状态)，登记新的就绪表。

若任务处于等待状态，将旧任务从等待列表注销，登记新任务



### OSTaskDel-未搞懂

INT8U  OSTaskDel (INT8U prio)

> OS_TASK_DEL_EN，OS_CRITICAL_METHOD，OS_ARG_CHK_EN，OS_FLAG_EN，OS_MAX_FLAGS，OS_EVENT_EN，OS_EVENT_MULTI_EN，OS_TASK_NAME_EN

判断是否处于中断状态，是否是系统任务，任务是否存在、占用，返回异常值

注销对应的就绪表，注销事件等待列表

调用OSTaskDelHook

OSTaskCtr减一，OSTCBPrioTbl对应位置0，任务TCB从OSTCBList删除，归还给OSTCBFreeList的第一个链表项



### OSTaskDelReq

INT8U  OSTaskDelReq (INT8U prio)

>  OS_TASK_DEL_EN，OS_CRITICAL_METHOD，OS_ARG_CHK_EN

不像OSTaskDel这么暴力，请求某个任务删除自己。

判断是否是系统任务，任务是否存在、占用，返回异常值

设置对方的OSTCBDelReq 属性为 OS_ERR_TASK_DEL_REQ，如果对象是自己，那么返回自己的OSTCBDelReq 属性


## 2.4、os_time.c

void  OSTimeDly (INT32U ticks)

将任务从就绪表中注销，并设置TCB相关的等待时间节拍属性

该任务的TCB还是存在的，只是操作系统不会再调度使用这个TCB了

## 2.5、os_sem.c

> OS_SEM_EN
>
> SEMAPHORES 信号量，处理关于信号量的函数库。用于限制共享资源的访问, 未能得到信号量将进入等待列表而不是就绪表！

```c
typedef struct os_event {
INT8U    OSEventType;       /* Type of event control block (see OS_EVENT_TYPE_xxxx) */
//void    *OSEventPtr; 有多个占有者，所以不像mutex表示占有者
INT16U   OSEventCnt;        /* Semaphore Count (not used if other EVENT type) */
OS_PRIO  OSEventGrp;        /* Group corresponding to tasks waiting for event to occur */
OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur */

#if OS_EVENT_NAME_EN > 0u
    INT8U   *OSEventName;
#endif

} OS_EVENT;
```



![](image/sem.png)



### OSSemPend 

> 获取信号量，只针对信号量的处理

void  OSSemPend (OS_EVENT *pevent, INT32U  timeout,INT8U     *perr)

* 检查输入参数的合法性
* 如果资源可用OSEventCnt>0就直接，减一

* 如果资源不可用，OSTCBStat标记OS_STAT_SEM
* 设置OSTCBStat任务状态和OSTCBStatPend = OS_STAT_PEND_OK 
* 调用OS_EventTaskWait
* 执行调度.
* 下次任务切换回该任务时，检验OSTCBStatPend，=OS_STAT_PEND_OK表示获取了信号，OS_ERR_PEND_ABORT**(OSSemPendAbort 给予标志)**表示信号获取出错
* OS_STAT_PEND_TO**(时钟节拍给予标志)**获取超时调用OS_EventTaskRemove从等待列表中删除任务

  

### OSSemPost

> pevent数值++，释放信号量

INT8U  OSSemPost (OS_EVENT *pevent)

* 如果有等待该信号的任务
* 调用OS_EventTaskRdy查找等待列表中最高的优先级任务将其delay置0，OSTCBStatPend = OS_STAT_PEND_OK ，OS_STAT_SEM状态mask掉。
* 在就绪表中登记任务
* 进行一次调度
* 如果没有等待的任务，pevent->OSEventCnt++

### OSSemDel

OS_EVENT  *OSSemDel (OS_EVENT  *pevent,  INT8U      opt, INT8U     *perr)

> OS_SEM_DEL_EN, OS_CRITICAL_METHOD, OS_ARG_CHK_EN, OS_EVENT_NAME_EN

删除信号量。opt可以选择不同的删除方式

OS_DEL_ALWAYS - 释放所有的等待任务，(将所有的等待该资源的任务从等待列表删除，进入就绪表)，然后将信号量结构名片归还给OSEventFreeList，返回0

OS_DEL_NO_PEND - 如果有等待任务，出错，返回该事件.如果没有等待任务，将信号量结构名片归还给OSEventFreeList ，返回0。

### OSSemQuery

> OS_SEM_QUERY_EN,

INT8U  OSSemQuery (OS_EVENT     *pevent,OS_SEM_DATA  *p_sem_data)

信号量查询

```C
typedef struct os_sem_data {
    INT16U  OSCnt;                 /* Semaphore count    */
    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
    OS_PRIO OSEventGrp;            /* Group corresponding to tasks waiting for event to occur */
} OS_SEM_DATA;
```

将信号量数据拷贝到p_sem_data，返回错误

### OSSemAccept

INT16U  OSSemAccept (OS_EVENT *pevent)

> OS_SEM_ACCEPT_EN

可以根据返回值是否大于零，检查资源是否可以访问

* 返回信号量cnt，如果cnt>0,将该信号量属性减1。

### OSSemPendAbort 

INT8U  OSSemPendAbort (OS_EVENT  *pevent, INT8U      opt,INT8U     *perr)

中止任务的信号请求

opt=OS_PEND_OPT_NONE中止等待列表中最高优先级的任务请求OSTCBStatPend=OS_STAT_PEND_ABORT

​	 = OS_PEND_OPT_BROADCAST 中止所有在等待的任务请求 

* 按opt选择模式，调用OS_EventTaskRdy 实现任务OSTCBStatPend位的改变，并将任务登记到就绪表中
* 执行一次任务调度，由任务根据OSTCBStatPend标志位进行处理

### OSSemSet 

void  OSSemSet (OS_EVENT  *pevent, INT16U     cnt, INT8U     *perr)

> OS_SEM_SET_EN

重新设定信号量的数值，只能在没有任务等待的情况下使用

## 2.6、OS_MUTEX.C

> 互斥型信号量
>
> ```c
> typedef struct os_event {
>     
> INT8U    OSEventType; /* Type of event control block (see OS_EVENT_TYPE_xxxx)    */
> void    *OSEventPtr;  /* 执行占有它的任务 */
> INT16U   OSEventCnt;  /* 高八位为提升优先级 低八位表示信号是否占有 */
> OS_PRIO  OSEventGrp;  /* Group corresponding to tasks waiting for event to occur */
> OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];/*List of tasks waiting for event to occur*/
> 
> #if OS_EVENT_NAME_EN > 0u
>     INT8U   *OSEventName;
> #endif
>     
> } OS_EVENT;
> ```
>
> 

![](image/mutex.png)

### OS_MUTEX_Accept



获取信号量

如果信号量被占用，返回False，任务并不suspend，继续运行

否则消除信号量，返回True



### OS_MUTEX_Pend

> 注意：不能再等待mutex期间改变任务优先级，

* 如果临时提升优先级比当前任务优先级低，出错
* 如果资源未被占用，占有资源，并保存任务原始优先级和临时提升优先级。返回
* 如果被占用，获取占用其的任务优先级和临时优先级
* **如果mutex的 临时提升优先级 比 占有任务的优先级 高(说明任务还没有提升优先级)，并且需要获取这个资源的任务优先级比它高(不然就不需要提升了，因为不会发生优先级反转的情况)，那么把任务优先级提升(将原优先级在就绪表中或者在等待列表【正在等待其他事件】中去除，将任务优先级设置为临时提升优先级，再按原样恢复)。（防止其他任务插在这两个任务之间，导致优先级反转）** 
* OSTCBStat 为mutex等待 和 OSTCBStatPend为OK，并调用***OS_EventTaskWait()***使任务进入等待列表，强制执行调度
* 再度调度回该任务，根据OSTCBStatPend请求返回状态，进行处理



### OSMutexCreate

> OS_EVENT  *OSMutexCreate (INT8U   prio,  INT8U  *perr)

* 初始化OSEventType，OSEventCnt，OSEventPtr占有任务，
* 调用OS_EventWaitListInit（）初始化等待列表



### OSMutexDel

>  OS_EVENT  *OSMutexDel (OS_EVENT *pevent,  INT8U  opt, INT8U *perr)
>
> * opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
>
> *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.

opt == OS_DEL_NO_PEND

* 如果没有任务占有。释放临时提升优先级，将Mutex归还给空白链表
* 如果有，返回错误

opt == OS_DEL_ALWAYS 

* 占有其的优先级(一定在就绪表中)，先调用OSMutex_RdyAtPrio()，在就绪表中修改优先级
* 通过while循环，调用OS_EventTaskRdy()，将所有等待任务调入就绪表
* 解除临时提升优先级的占用，将Mutex归还给空白链表

如果有任务等待，则此处强制任务调度



### OSMutexPost

> INT8U  OSMutexPost (OS_EVENT *pevent)判断是否是占有者调用，否则出错

* 如果需要的话，首先将占有者优先级调回原始优先级，（很重要的一步，使得任务返回原来的优先级）
* 如果没有任务在等待，那么直接修改信号量为有效，就退出
* 如果任务有在等待，那么选择最高等待优先级进入就绪表，调用函数OS_EventTaskRdy。
* 在mutex结构中记录该最高等待优先级



### OSMutexQuery

INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA  *p_mutex_data)

```c
typedef struct os_mutex_data {
    OS_PRIO OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur*/
    OS_PRIO OSEventGrp;   /* Group corresponding to tasks waiting for event to occur */
    BOOLEAN OSValue;      /* Mutex value (OS_FALSE = used, OS_TRUE = available) */
    INT8U   OSOwnerPrio;  /* Mutex owner's task priority or 0xFF if no owner    */
    INT8U   OSMutexPIP;   /* Priority Inheritance Priority or 0xFF if no owner  */
} OS_MUTEX_DATA;
```



### OSMutex_RdyAtPrio

> static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb, INT8U    prio)
>
> This function makes a task ready at the specified priority 将优先级从临时提升优先级恢复

将任务的就绪表中删除，变成低优先级后再次注册就绪表

## 2.7、OS_MBOX.C

> 消息邮箱

```c
typedef struct os_event {
    
INT8U    OSEventType; /* Type of event control block (see OS_EVENT_TYPE_xxxx)    */
void    *OSEventPtr;  /* Pointer to message or queue structure                   */
//INT16U   OSEventCnt;  /* 高八位为提升优先级 低八位表示信号是否占有 */
OS_PRIO  OSEventGrp;  /* Group corresponding to tasks waiting for event to occur */
OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];/*List of tasks waiting for event to occur*/

#if OS_EVENT_NAME_EN > 0u
    INT8U   *OSEventName;
#endif
    
} OS_EVENT;
```



## 2.8、OS_Q.C

> 消息队列

```c
typedef struct os_event {
    
INT8U    OSEventType; /* Type of event control block (see OS_EVENT_TYPE_xxxx)    */
void    *OSEventPtr;  /* 队列结构体 */
//INT16U   OSEventCnt;  /* 高八位为提升优先级 低八位表示信号是否占有 */
OS_PRIO  OSEventGrp;  /* Group corresponding to tasks waiting for event to occur */
OS_PRIO  OSEventTbl[OS_EVENT_TBL_SIZE];/*List of tasks waiting for event to occur*/

#if OS_EVENT_NAME_EN > 0u
    INT8U   *OSEventName;
#endif
    
} OS_EVENT;
```



删除

所有等待的任务都进入就绪表，并且接收消息为NULL



### OS_QInit()

系统初始化时调用



## 2.9、os_flag.c

```c
typedef struct os_flag_grp {                /* Event Flag Group  */
    
INT8U OSFlagType;         /* 只能为 OS_EVENT_TYPE_FLAG */
void *OSFlagWaitList;     /* 等待任务链表 */
OS_FLAGS OSFlagFlags;     /* 8, 16 or 32 bit flags 信号量集*/
    
#if OS_FLAG_NAME_EN > 0u
    INT8U        *OSFlagName;
#endif
    
} OS_FLAG_GRP;
```

### OSFlagCreate

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,  INT8U    *perr)

> OS_FLAG_NAME_EN

从空白的OS_FLAG_GRP链表中获取一个空结构，初始化OSFlagWaitList=NULL(没有等待任务)

### OSFlagPend

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp,  OS_FLAGS flags, INT8U wait_type, INT32U timeout,  INT8U *perr)

> 信号量集请求，OS_FLAG_CONSUME 可以设置请求成功之后是否消费掉对应的信号(注意OS_FLAG_WAIT_SET_ANY时，如果有两个置1，这两个1全部会被消费)， OS_FLAG_WAIT_CLR_EN

 flags为任务需要的信号集对应的子集的掩码，可以通过与OSFlagFlags获取对应的信号集子集是否满足要求。

* 首先通过wait_type & OS_FLAG_CONSUME判断是否flag会被消费(不为零表示会被消费)
* 根据wait_type和参数flags掩码判断请求是否能够立刻响应
* 可以响应时，消费信号集，设置OSTCBCur->OSTCBFlagsRdy = flags_rdy，记录相应任务请求的对应信号集，返回flags_rdy(请求到的信号量集)，这对于ANY的wait_type很有用
* 无法响应时调用OS_FlagBlock，将任务加入等待双向链表。信号满足时，消费信号量，返回请求的请求到的信号量数值
* 挂起状态设为OS_STAT_PEND_OK，执行任务调度
* 任务再次调回来时，判断OSTCBStatPend挂起的状态
* 如果未成功(时钟节拍给予标志OS_STAT_PEND_TO)， 调用OS_FlagUnlink，挂起状态设为OS_STAT_PEND_OK，返回请求到的信号量集和对应的错误
* 如果调用成功(标志还是OS_STAT_PEND_OK)，则**利用OSTCBCur->OSTCBFlagsRdy中的记录**(来自post- OS_FlagTaskRdy)将消费信号量，返回请求到的信号量集

### OSFlagPost

OS_FLAGS OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)

> OS_CRITICAL_METHOD,OS_SAFETY_CRITICAL, OS_ARG_CHK_EN

* 根据opt，修改pgrp中的OSFlagFlags
* 扫描等待任务双向链表，如果某个等待任务满足条件，调用OS_FlagTaskRdy函数，置位任务调度标志位
* 根据标志位，进行任务调度
* 返回目前的flag集状态

### OSFlagDel

OS_FLAG_GRP *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U \*perr)

> OS_FLAG_DEL_EN， 该函数执行时间与等待的任务数量成正比，会导致较长时间无法进入中断(节拍函数)

删除flags信号集结构，删除等待的任务链表节点。opt可以选择删除方式，强行删除或者只有没有任务等待的情况下才删除

* ~~强行删除：~~
* ~~将所有等待的任务登记入就绪表中，难点是如果释放等待链表的节点空间~~
* ~~将对应flags还给初始化生成的空白flag结构链表，将OSFlagWaitList设为NULL。~~

* 首先判断有没有等待的任务
* 如果没有，将对应flags还给初始化生成的空白flag结构链表，OSFlagWaitList组成链表
* 如果有，如果opt是强行删除，调用OS_FlagTaskRdy 将链表中的所有任务都在就绪表中注册同时修改状态，同时为了使得最高优先级的任务能够优先执行，需要进行任务调度
* 如果不是强行删除，那么出错

### OSFlagAccept

OS_FLAGS OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)

> OS_FLAG_ACCEPT_EN，请求信号集后，任务不需要等待，直接继续执行；不会设置OSTCBCur->OSTCBFlagsRdy位

- 首先通过wait_type & OS_FLAG_CONSUME判断是否flag会被消费(不为零表示会被消费)
- 根据wait_type和参数flags掩码判断请求是否能够立刻响应
- 不能就直接出错，返回当前信号量集的状态值
- 如果可以，消费掉信号，返回当前信号量集的状态值
- 如果wait_type不符合要求，直接返回0

### OSFlagNameGet

INT8U OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U **pname, INT8U *perr)

> OS_FLAG_NAME_EN，获取信号集名称

* 获取名称到pname中，pname是指向字符串指针的指针，ASCII可以用int8u表示
* 调用OS_StrLen函数，返回名称长度

### OSFlagNameSet

void OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr) 

> OS_FLAG_NAME_EN

pgrp->OSFlagName = pname

### OSFlagPendGetFlagsRdy

获取OSTCBCur->OSTCBFlagsRdy，以询问该任务请求到的信号集。

### OSFlagQuery

OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,  INT8U *perr)

返回pgrp->OSFlagFlags的值

### OS_FlagBlock

static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp, OS_FLAG_NODE *pnode,  OS_FLAGS flags, INT8U         wait_type,  INT32U timeout)

将等待信号量集的任务加入到flag的等待双向链表的头部，同时抹除其就绪表中的注册

等待链表的节点结构如下：

```c
typedef struct os_flag_node {               /* Event Flag Wait List Node    */
    void         *OSFlagNodeNext;           /* Pointer to next     NODE in wait list  */
    void         *OSFlagNodePrev;           /* Pointer to previous NODE in wait list   */
    void         *OSFlagNodeTCB;            /* Pointer to TCB of waiting task   */
    void         *OSFlagNodeFlagGrp;        /* Pointer to Event Flag Group    */
    OS_FLAGS      OSFlagNodeFlags;          /* Event flag to wait on  等待的是什么资源*/
    INT8U         OSFlagNodeWaitType;       /* Type of wait:等待条件，用于资源到来时的检测*/
                                            /*      OS_FLAG_WAIT_AND         */
                                            /*      OS_FLAG_WAIT_ALL         */
                                            /*      OS_FLAG_WAIT_OR         */
                                            /*      OS_FLAG_WAIT_ANY     */
} OS_FLAG_NODE;
```



### OS_FlagInit

void  OS_FlagInit (void)

操作系统初始化时调用

### OS_FlagTaskRdy

static BOOLEAN OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)

* 任务等待时间清零，状态清除flag，挂起标志设为OS_STAT_PEND_OK
* **设置OSTCBCur->OSTCBFlagsRdy**
* 如果此时，任务状态为OS_STAT_RDY(0x00), 在就绪表中登记，任务调度
* 如果任务状态被suspend或者什么的，不进行调度
* 调用OS_FlagUnlink
* 返回调度状态(True/Flase)

### OS_FlagUnlink

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)

将一个任务等待节点从等待双向链表中删除。空间的释放单片机自动完成

需要先判断需要删除的节点位于什么位置



## 3.0、os_tmr.c

```c
typedef  struct  os_tmr {
    INT8U            OSTmrType;                       /* Should be set to OS_TMR_TYPE  */
    OS_TMR_CALLBACK  OSTmrCallback;                   /* 回调函数 */
    void            *OSTmrCallbackArg;                /* 传递参数*/
    void            *OSTmrNext;                       /* Double link list pointers    */
    void            *OSTmrPrev;
    INT32U           OSTmrMatch;       /* Timer expires when OSTmrTime == OSTmrMatch  */
    INT32U           OSTmrDly;         /* Delay time before periodic update starts  */
    INT32U           OSTmrPeriod;     /* 定时周期                 */
#if OS_TMR_CFG_NAME_EN > 0u
    INT8U           *OSTmrName;                       /* Name to give the timer     */
#endif
    INT8U            OSTmrOpt;                        /* Options (see OS_TMR_OPT_xxx) */
    INT8U            OSTmrState;      /* Indicates the state of the timer:  */
                                      /*     OS_TMR_STATE_UNUSED   */
                                      /*     OS_TMR_STATE_RUNNING    */
                                      /*     OS_TMR_STATE_STOPPED  */
} OS_TMR;
```



```c
typedef  struct  os_tmr_wheel {
    OS_TMR          *OSTmrFirst;       /* Pointer to first timer in linked list  */
    INT16U           OSTmrEntries;
} OS_TMR_WHEEL;
```





### osTmr_Init

> void  OSTmr_Init (void)
>
> OS_TMR_EN

* 初始化OSTmrTbl内存空间，和OSTmrWheelTbl内存空间
* 建立定时器单向链表 OSTmrState 为 ***OS_TMR_STATE_UNUSED*** 
* 初始化OSTmrTime，OSTmrUsed，OSTmrFree
* 建立两个信号量OSTmrSem，OSTmrSemSignal
* 调用OSTmr_InitTask，建立定时器任务



### OSTmr_InitTask

* 调用OSTaskCreate, 建立定时器, OSTmr_InitTask



### OSTmr_Task

> 定时器任务功能
>
> static  void  OSTmr_Task (void *p_arg)

* 调用OSSemPend，获取OSTmrSemSignal

* OSTmrTime++

* 根据OSTmrTime寻找对应的OSTmrWheelTbl，定时器轮片位置，扫描其中的定时器

* 如果定时器到点了，那么调用回调函数，***(\*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg)***。传入参数自带ptmr



### OSTmrCreate

> OSIntNesting
>
> OS_TMR  *OSTmrCreate (INT32U           dly,
>                       INT32U           period,
>                       INT8U            opt,
>                       OS_TMR_CALLBACK  callback,
>                       void            *callback_arg,
>                       INT8U           *pname,
>                       INT8U           *perr)

* 调用***OSTmr_Alloc*** 获取空白timer结构体
* 定时器状态为**OS_TMR_STATE_STOPPED**



### OSTmr_Alloc

> static  OS_TMR  *OSTmr_Alloc (void)

* 从OSTmrFreeList获取tmr空间
*  OSTmrUsed++、OSTmrFree--



### OSTmr_Free

>  static  void  OSTmr_Free (OS_TMR *ptmr)

* **OS_TMR_STATE_UNUSED**
* tmr 内存归还给 OSTmrFreeList
* OSTmrUsed--、OSTmrFree++



### OSTmrDel

BOOLEAN  OSTmrDel (OS_TMR  *ptmr,  INT8U   *perr)

根据定时器不同的状态，分别将tmr内存归还



### OSTmrStateGet

获取定时器状态



### OSTmrStart

根据定时器不同的状态，调用***OSTmr_Link*** 将定时器挂在时间轮片上

OS_TMR_STATE_RUNNING

- 先调用***OSTmr_Unlink*** ，然后重新调用***OSTmr_Link*** 

OS_TMR_STATE_COMPLETED/OS_TMR_STATE_STOPPED

- 调用***OSTmr_Link*** 



### OSTmr_Link

> static  void  OSTmr_Link (OS_TMR  *ptmr,  INT8U    type)

* 设定定时器几个节拍后启动，OStmrPeriod或者OSTmrDly
* 将定时器挂在 **ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE** 上
* 设置定时器状态为OS_TMR_STATE_RUNNING



### OSTmr_Unlink



### OSTmrStop

> BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
>                     INT8U    opt,
>                     void    *callback_arg,
>                     INT8U   *perr)

OS_TMR_STATE_RUNNING

* 调用***OSTmr_Unlink*** ，根据opt选择是否要在停止时钟之前调用一次回调函数

OS_TMR_STATE_COMPLETED/OS_TMR_STATE_STOPPED

* 出错，返回OS_TRUE

OS_TMR_STATE_UNUSED

* 出错，返回OS_FALSE

-------------------------------------------

### OSTmrSignal

> 控制OSTmr_Task的就绪和等待
>
> 在***OSTimeTick*** 的***OSTimeTickHook*** 中调用

释放OSTmrSemSignal信号，一般放于中断函数中，这样就能周期性启动定时器任务了



## 3.1、os_mem.c

![](image/mem.png)

```c
typedef struct os_mem {      /* MEMORY CONTROL BLOCK     */
    void   *OSMemAddr;       /* Pointer to beginning of memory partition    */
    void   *OSMemFreeList;   /* Pointer to list of free memory blocks       */
    INT32U  OSMemBlkSize;    /* Size (in bytes) of each block of memory     */
    INT32U  OSMemNBlks;      /* Total number of blocks in this partition    */
    INT32U  OSMemNFree;      /* 分区中可用的内存块 */
#if OS_MEM_NAME_EN > 0u
    INT8U  *OSMemName;       /* 内存分区名称 */
#endif
} OS_MEM;
```



### OS_MemInit

> void  OS_MemInit (void)
>
> OS_MAX_MEM_PART 结构体数量

* 初始化OSMemTbl，建立单向链表



### OSMemCreate

>OS_MEM  *OSMemCreate (void   *addr,
>                      INT32U  nblks,
>                      INT32U  blksize,
>                      INT8U  *perr)
>
>partition分区起始地址，分区中内存块数量，内存块字节大小，错误

```c
plink = (void **)addr;      /* addr的内容看做是一个指针 */
pblk  = (INT8U *)addr;	    //addr看做是一个指向int8U的指针
loops  = nblks - 1u;
for (i = 0u; i < loops; i++) {  //循环内存块
    pblk +=  blksize;       /* 指向下一个内存块首地址   */
    *plink = (void  *)pblk; /* 指针存储于plink中      */
    plink = (void **)pblk;  /* 修改plink的内容为该指针 */
}
```

![](image/可分配内存结构1.png)



### **OSMemGet

> void  *OSMemGet (OS_MEM  *pmem, INT8U   *perr)

从pmem获取一个内存块,pblk即为获取的内存块首地址。

```c
pblk = pmem->OSMemFreeList;    /* 将内存块一的首地址返回 */
pmem->OSMemFreeList = *(void **)pblk;  /* 将内存块一的值 其实指向的是下一个内存块，所以强制转化为指针后其实是将，下一个内存块地址赋值给了OSMemFreeList
```

### OSMemPut

> INT8U  OSMemPut (OS_MEM  *pmem, void    *pblk)
>
> 将 pblk内存块，归还到pmem

* 首先判断空闲内存是否是满的，如果是，那么报错，说明要归还的内存不属于这个pmem
* 归还到内存块的单向链表中

### OSMemNameSet/OSMemNameGet

> OSIntNesting 无法嵌套

设置名称和获取名称



### OSMemQuery

> INT8U  OSMemQuery (OS_MEM       *pmem, OS_MEM_DATA  *p_mem_data)

将数据存储于OS_MEM_DATA

```c
typedef struct os_mem_data {
    void   *OSAddr;       /* Pointer to the beginning address of the memory partition */
    void   *OSFreeList;   /* Pointer to the beginning of the free list of memory blocks*/
    INT32U  OSBlkSize;    /* Size (in bytes) of each memory block                 */
    INT32U  OSNBlks;      /* Total number of blocks in the partition      */
    INT32U  OSNFree;      /* Number of memory blocks free              */
    INT32U  OSNUsed;      /* Number of memory blocks used          */
} OS_MEM_DATA;
```





## 2.9、os_cpu_c.c

* 定义大量钩子函数
* OS_CPU_SysTickHandler() 【中断服务函数】
* OS_CPU_SysTickInit()【中断初始化】

 

### OSTimeTickHook

时间中断服务函数中调用的钩子函数



## app_cfg.h

定义任务的优先级、堆栈大小



## os_cpu.h 变量类型等底层

* 定义单片机的变量类型
* 不可中断代码存储SR寄存器的宏
* 定义栈的生长方向
* 声明与汇编代码相关的函数(任务调度、PendSV中断服务函数，OSStartHighRdy)



## os_cfg.H 功能配置

非常重要的系统配置文件，参考C/OS-II Configuration Manual 

几乎所有的与操作系统有关的重要宏的定义，方便裁剪和增加系统功能



***OS_CFG.h中可配置项:***

* OS_FLAG_EN 初始化 OSFlagFreeList【OS_MAX_FLAGS】单向链表

* OS_MEM_EN 初始化内存管理 OSMemFreeList【OS_MAX_MEM_PART】单向链表

* OS_Q_EN 初始化空队列链表 OSQFreeList【OS_MAX_QS】单向链表

* OS_TASK_STAT_EN 创建统计任务 OS_TaskStat

* OS_TMR_EN 初始化 OSTmrFreeList【OS_TMR_CFG_MAX】单向链表

* OS_DEBUG_EN 允许调试信息



## ucosii.h 系统结构体

#include <app_cfg.h>
#include <os_cfg.h>
#include <os_cpu.h>

定义了大量数据结构体和数组，还有一部分宏。

* 内核版本 OS_VERSION
* 定义error宏，任务状态宏

* TCB 结构体

```c
typedef struct os_tcb {
    OS_STK          *OSTCBStkPtr;           /* 栈顶指针*/

#if OS_TASK_CREATE_EXT_EN > 0u
    void     *OSTCBExtPtr;  /* Pointer to user definable data for TCB extension */
    OS_STK   *OSTCBStkBottom;        /* Pointer to bottom of stack             */
    INT32U  OSTCBStkSize;    /* Size of task stack (in number of stack elements)*/
    INT16U    OSTCBOpt;      /* Task options as passed by OSTaskCreateExt()   */
    INT16U    OSTCBId;       /* Task ID (0..65535)               */
#endif

    struct os_tcb   *OSTCBNext;      /* 链表对象*/      
    struct os_tcb   *OSTCBPrev;            

#if (OS_EVENT_EN)
    OS_EVENT        *OSTCBEventPtr;  /*event control block使任务等待的事件指针，任务进入等待，此模式下任务是不可能同时等待两个事件的*/
#endif

#if (OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u)
    OS_EVENT       **OSTCBEventMultiPtr;    /*Pointer to multiple event control blocks*/
#endif

#if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
    void     *OSTCBMsg;      /* Message received from OSMboxPost() or OSQPost()任务接收的邮箱消息*/
#endif

#if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
#if OS_TASK_DEL_EN > 0u
    OS_FLAG_NODE    *OSTCBFlagNode;    /* Pointer to event flag node 信号集等待链接节点 */
#endif
    OS_FLAGS OSTCBFlagsRdy; /*Event flags that made task ready to run是任务能够运行的信号集*/
#endif

    INT32U OSTCBDly;/*N ticks to delay task or,timeout waiting for event延迟或等待信号时间*/
    INT8U    OSTCBStat;                     /* 任务状态，处于等待的类型(信号量，信号集等)*/
    INT8U            OSTCBStatPend;         /* 任务请求状态    */
    INT8U            OSTCBPrio;             /* 任务优先级 (0 == highest)  */

    INT8U          OSTCBX; /* Bit position in group  corresponding to task priority   */
    INT8U          OSTCBY; /* Index into ready table corresponding to task priority   */
    OS_PRIO        OSTCBBitX;/* Bit mask to access bit position in ready table 		  */
    OS_PRIO        OSTCBBitY;/* Bit mask to access bit position in ready group		  */

#if OS_TASK_DEL_EN > 0u
    INT8U            OSTCBDelReq;           /* 删除请求标志 */
#endif

#if OS_TASK_PROFILE_EN > 0u
    INT32U           OSTCBCtxSwCtr;         /* 切换到该任务次数 */
    INT32U           OSTCBCyclesTot;        /* 任务运行的时间节拍数目 */
    INT32U OSTCBCyclesStart; /* Snapshot of cycle counter at start of task resumption */
    OS_STK          *OSTCBStkBase;          /* 栈底指针  */
    INT32U           OSTCBStkUsed;          /* 栈使用字节数目 */
#endif

#if OS_TASK_NAME_EN > 0u
    INT8U           *OSTCBTaskName;			/* 任务 人能看懂的名字 */
#endif

#if OS_TASK_REG_TBL_SIZE > 0u
    INT32U           OSTCBRegTbl[OS_TASK_REG_TBL_SIZE];
#endif
} OS_TCB;
```



```c
OSTCBStat; 任务状态
-----------------------------------------------------------
#define  OS_STAT_RDY                 0x00u  /* Ready to run  */
#define  OS_STAT_SEM                 0x01u  /* Pending on semaphore  */
#define  OS_STAT_MBOX                0x02u  /* Pending on mailbox  */
#define  OS_STAT_Q                   0x04u  /* Pending on queue    */
#define  OS_STAT_SUSPEND             0x08u  /* Task is suspended   */
#define  OS_STAT_MUTEX               0x10u  /* Pending on mutual exclusion semaphore  */
#define  OS_STAT_FLAG                0x20u  /* Pending on event flag group  */
#define  OS_STAT_MULTI               0x80u  /* Pending on multiple events   */

#define OS_STAT_PEND_ANY (OS_STAT_SEM|OS_STAT_MBOX|OS_STAT_Q|OS_STAT_MUTEX|OS_STAT_FLAG)
```


```c
OSTCBStatPend; 挂起结束的原因
------------------------------------------------------------
OS_STAT_PEND_ABORT 被禁止
OS_STAT_PEND_OK 无出错结束挂起
OS_STAT_PEND_TO (timeout) 获取超时
```


# 3、系统节拍

> main函数分析完成后，CPU由操作系统接管。接下来要如何分析呢
>
> 我们知道，没有人的干预，操作系统操作很死板，只是一个大循环或者重复的过程，通过每隔一定时间重复进行任务切换，信号量判断等方式进行。所以我们必须找到系统的定时器和定时器中断程序，这是解读操作系统的关键所在。

我们在库中只能找到一个定时器函数，位于os_core.c文件中

uC/OS-II在每次响应定时中断时调用OSTimeTick()做了两件事情：

* 是给计数器OSTime加1;
* 是遍历任务控制块链表中的所有任务控制块，把各个 任务控制块中用来存放任务延时时限的OSTCBDly变量减1，并使该项为0，同时又不使被挂 起的任务进入就绪状态。



  	简单地说，函数OSTimeTick()的任务就是在每个时钟节拍了解每个任务的延时状态，使其中已经到了延时时限的非挂起任务进入就绪状态。

```c
void  OSTimeTick (void)
{
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0u
    BOOLEAN    step;
#endif
    
#if OS_CRITICAL_METHOD == 3u           /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0u;
#endif

#if OS_TIME_TICK_HOOK_EN > 0u
    OSTimeTickHook();                 /* Call user definable hook   扩展功能程序  */
#endif
    
#if OS_TIME_GET_SET_EN > 0u
    OS_ENTER_CRITICAL();              /* Update the 32-bit tick counter  */
    OSTime++;
    OS_EXIT_CRITICAL();
#endif

    //很重要，时钟节拍初始化使能之后，即使进入中断也不会做什么，直接退出
    if (OSRunning == OS_TRUE) {	
#if OS_TICK_STEP_EN > 0u
        switch (OSTickStepState) {    /* Determine whether we need to process a tick  */
            case OS_TICK_STEP_DIS:    /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
                 break;

            case OS_TICK_STEP_WAIT:   /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;     /*     .. OSTickStepState to OS_TICK_STEP_ONCE */
                 break;

            case OS_TICK_STEP_ONCE:   /* Yes, process tick once and wait for next ... */
                 step = OS_TRUE;  	  /*  ... step command from uC/OS-View    */
                 OSTickStepState = OS_TICK_STEP_WAIT;
                 break;

            default:                  /* Invalid case, correct situation     */
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {       /* Return if waiting for step command  */
            return;
        }
#endif
        
        ptcb = OSTCBList;             /* Point at first TCB in TCB list    */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) { /* 搜索整个TCB双向链表*/
            OS_ENTER_CRITICAL();
            if (ptcb->OSTCBDly != 0u) {   /* No, Delayed or waiting for event with TO */
                ptcb->OSTCBDly--; 
                if (ptcb->OSTCBDly == 0u) { /* 如果延迟时间到了 */

                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
                        ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;  /* 清除pend类型标志 */
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;     /*  PEND状态设置为 timeout    */
                    }
                    else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;	/* 普通延迟结束 */
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* 任务如果未挂起*/
                        OSRdyGrp               |= ptcb->OSTCBBitY;    /* 就绪表中登记 */
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;       /* Point at next TCB in TCB list       */
            OS_EXIT_CRITICAL();
        }
    }
}
```

**那么另一个问题来了，操作系统是怎么调用这个函数的呢？**

文献【1】中提到，调用是在汇编程序的中断中实现，但是我们并没有找到相关的汇编代码。我们猜测是通过C语言设定定时器的中断实现的，所以我们在stm32的中断服务程序种查找，发现果不其然，在stm32f10x_it.c中的中断服务函数如下：

```c
void SysTick_Handler(void)
{
    OSIntEnter(); 
    OSTimeTick(); 		//调用上述函数
    OSIntExit(); 		//中断级任务调度函数
}
```

**最后，不要忘记了，既然存在定时器中断，那么定时周期是多少，在哪里修改和初始化的呢？**

在BSP.c,关于硬件的这部分程序中，我们找到了如下初始化代码

```c
void BSP_Init(void)
{
    SystemInit();		/* 配置系统时钟为72M */	
	SysTick_init();		/* 初始化并使能SysTick定时器 */
    GPIO_Config();  	/* 端口初始化 */
	USART1_Config();	/* 串口初始化 */
}
```

```c
/*
 * 函数名：SysTick_init
 * 描述  ：配置SysTick定时器
 * 输入  ：无
 * 输出  ：无
 */
void SysTick_init(void)
{
    SysTick_Config(SystemFrequency/OS_TICKS_PER_SEC);		//初始化并使能SysTick定时器
}
```

其中OS_TICKS_PER_SEC = 1000；实现每秒定时器中断1000次。

SysTick_Config函数在\CMSIS\core_cm3.h中实现，这是KEIL编译器自己提供的函数库

这样，整个操作系统的运作流程就打通了。



实际上，操作系统实际的时钟节拍是在os_cpu_c.c中OS_CPU_SysTickHandler() 【中断服务函数】,OS_CPU_SysTickInit()【中断初始化】这两个函数实现的。但是这两个函数基本都是通过修改寄存器来实现功能的，比较复杂，而且官方是采用IAR编译平台的，有些底层的函数无法调用，所以野火采用Keil自带的函数去实现，这里该段函数被设置为不编译。

![操作系统的运作流程](image\操作系统的运作流程.png)



# 4、汇编语言解读

> 汇编语言一般用于处理C语言无法完成的任务。譬如涉及中断，寄存器的操作，就必须要用汇编语言了



## 基本知识

[**单片机在调用子程序时，进行了怎样的堆栈操作？**](<http://www.elecfans.com/emb/xitong/20171116580315.html>)

　　栈： 在函数调用时，第一个进栈的是主函数中函数调用后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

　　当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

　　堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

[**函数调用栈空间**](<https://blog.csdn.net/beyond702/article/details/52228683>)

​	在ARM指令系统中是地址递减栈，入栈操作的参数入栈顺序是从右到左依次入栈，而参数的出栈顺序则是从左到右的你操作。包括push/pop和LDMFD/STMFD等。比如指令 push {fp, sp, lr, pc}执行的结果就是图1中栈的样子，pc被首先入栈存在高地址，从右到左依次入栈，fp存在低地址。

[**与函数栈有关的寄存器**](<https://www.cnblogs.com/chyl411/p/4579053.html>)

* r15 PC The Program Counter.

* r14 LR The Link Register.

* r13 SP The Stack Pointer.

* r12 IP The Intra-Procedure-call scratch register. （可简单的认为暂存SP）

* r11是optional的，被称为FP，即frame pointer。



[**stack frame**](<https://blog.csdn.net/beyond702/article/details/52228683>)

​	stack我们都知道，每一个进程都有自己的栈。考虑进程执行时发生函数调用的场景，母函数和子函数使用的是同一个栈，在通常的情况下，我们并不需要区分母函数和子函数分别使用了栈的哪个部分。但是，当我们需要在执行过程中对函数调用进行backtrace(回溯)的时候，这一信息就很重要了。

​	简单的说，stack frame就是一个函数所使用的stack的一部分，所有函数的stack frame串起来就组成了一个完整的栈。stack frame的两个边界分别由FP和SP来限定。

**backtrace**

​	在程序执行过程中（通常是发生了某种意外情况而需要进行调试），通过SP和FP所限定的stack frame，就可以得到母函数的SP和FP，从而得到母函数的stack frame（PC，LR，SP，FP会在函数调用的第一时间压栈），以此追溯，即可得到所有函数的调用顺序。

![函数栈](image\函数栈.png)

​	ARM压栈的顺序很是规矩，依次为当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、*传入参数个数及指针、*本地变量(在该函数所在域的变量)和临时变量(编译器临时产生的变量)。如果函数准备调用另一个函数，跳转之前临时变量区（R0-R3）先要保存另一个函数的参数。

```c
int func(int a, int b, int c, int d)
{
	return 1;
}

int main()
{
	int i = 1, j = 2;
	func(i, j, 3, 4);
	return 0;
}
```

其对应的栈示意图如图：

![函数栈2](image\函数栈2.png)

***注意***：需要注意的是，这种压栈的方式，并不是cortex-M3单片机自动完成的，而是类似于某种约定或者标准，或者协议方便backtrace调试。

## [PendSV中断服务程序](<http://blog.chinaunix.net/uid-22072065-id-5770131.html>)

用于上下文切换

```scheme
OS_CPU_PendSVHandler
    CPSID   I                                    ; 屏蔽除NMI和硬fault中断，
    
    ;存储剩余的一半寄存器
    MRS     R0, PSP                              ; 读取进程SP
    CBZ     R0, OS_CPU_PendSVHandler_nosave      ; 如果为零(第一次切换任务)，不需要保存现场
    SUBS    R0, R0, #0x20                        ; 保存R4-R11,R0为栈顶
    STM     R0, {R4-R11}						 ; STM默认自增，所以上面需要腾出空间，R0不变
	
    ;当前任务块的栈顶存储
    LDR     R1, =OSTCBCur                        ; R1=OSTCBCur(TCB指针)的地址
    LDR     R1, [R1]							 ; 获取当前TCB任务块指针(地址)
    STR     R0, [R1]                             ; [R1]为指针指向的内容。R0栈顶存储到当前任务块指针指向的第一个单元即SP Pointer，至此现场保存完毕


; 调用用户钩子函数
; 获取最高优先级的就绪任务，获取任务的堆栈到R0
; 从堆栈读取数据到R4-R11，恢复现场
; 返回。
OS_CPU_PendSVHandler_nosave
    PUSH    {R14}                     ; Save LR exc_return value
    LDR     R0, =OSTaskSwHook         ; 调用OSTaskSwHook();
    BLX     R0
    POP     {R14}

    ; OSPrioCur = OSPrioHighRdy
    LDR     R0, =OSPrioCur           ; 设置当前优先级为最高就绪优先级，R0为OSPrioCur变量的地址
    LDR     R1, =OSPrioHighRdy
    LDRB    R2, [R1]
    STRB    R2, [R0]

    ; OSTCBCur  = OSTCBHighRdy;
    LDR     R0, =OSTCBCur            ; 设置当前最高就绪的任务，R0为OSTCBCur的地址(指针)
    LDR     R1, =OSTCBHighRdy
    LDR     R2, [R1]				 ; [R0]为R0指针指向的内容，OSTCBCur内容
    STR     R2, [R0]

    LDR     R0, [R2]                 ; SP=OSTCBHighRdy->OSTCBStkPtr;因为定义的结构第一个成员就是指向堆栈的指针
    LDM     R0, {R4-R11}             ; 从堆栈中读取数据到R4-R11。R0没有发生改变，权威手册P61
    ADDS    R0, R0, #0x20			 ; 堆栈是四个字节对齐的，所以此处SP相当于挪动8个存储单元，
    MSR     PSP, R0                  ; Load PSP with new process SP
    ORR     LR, LR, #0x04            ; 确保返回后使用的是PSP cortex-M3权威手册P139
    CPSIE   I
    BX      LR                       ; 中断返回会自动恢复剩余的一半寄存器，CP,PSR,RL

    END

```

## OSCtxSw/OSIntCtxSw

发起一个PendSV的中断，该中断优先级最低，在退出其他中断之后会进行上下文切换



## OSStartHighRdy

在操作系统第一次上下文切换时，由OSStart()调用

* 设置PendSV中断的优先级
* 初始化用户进程堆栈
* 设置OSRunning系统启动标志位
* 触发一次中断

```scheme
OSStartHighRdy
    LDR     R0, =NVIC_SYSPRI14                                  ; Set the PendSV exception priority，设置优先级最高
    LDR     R1, =NVIC_PENDSV_PRI
    STRB    R1, [R0]

    MOVS    R0, #0                                              ; Set the PSP to 0 for initial context switch call 设置进程堆栈为0
    MSR     PSP, R0

    LDR     R0, =OSRunning                                      ; OSRunning = TRUE 系统启动
    MOVS    R1, #1
    STRB    R1, [R0]

    LDR     R0, =NVIC_INT_CTRL                                  ; 触发中断，Trigger the PendSV exception (causes context switch)
    LDR     R1, =NVIC_PENDSVSET
    STR     R1, [R0]

    CPSIE   I                                                   ; Enable interrupts at processor level，进入PENDSV中断

OSStartHang
    B       OSStartHang
```



## 不可中断代码段

> 用于不可中断代码，前后的中断屏蔽或者中断允许设置
>
> OS_CRITICAL_METHOD == 3时调用的函数，
>
> OS_ENTER_CRITICAL调用OS_CPU_SR_Save函数，并用cpu_sr变量保存返回值(返回值位于R0)
>
> OS_EXIT_CRITICAL调用OS_CPU_SR_Restore函数，并传入cpu_sr用于恢复

```scheme
; 注意，R0用于存储CPU的psr寄存器。 R0是restore函数传入的参数，R0也是save函数中return的参数，
OS_CPU_SR_Save					; Set prio int mask to mask all (except faults) PRIMASK 
    MRS     R0, PRIMASK         ; 保存进入不可中断代码之前的标志位
    CPSID   I					; 关中断，详见cortex M3 权威指南P42
    BX      LR

OS_CPU_SR_Restore				; 恢复不可中断代码之前的PRIMASK标志位
    MSR     PRIMASK, R0
    BX      LR
```



# 5. 系统设计的处理

### 关于就绪表的操作？

* 登记
* 删除
* 查找最高优先级任务

![](image/就绪表.png)

<p align="center">就绪表</p>
1. TCB的初始化，TCB就绪**登记**过程中，任务就绪表(x,y)的计算方式

```c
#if OS_LOWEST_PRIO <= 63	/* 撑死是个8X8的矩阵 */
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* 除以8的整数，得到y坐标*/
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);		/* 除8的余数，得到x坐标 */
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);//位对应某个组
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);//位对应某个组的某一位
#else						/* 撑死是个16x16的矩阵 */
        ptcb->OSTCBY             = (INT8U)((prio >> 4) & 0xFF); /* 除以16的整数，得到y坐标      */
        ptcb->OSTCBX             = (INT8U) (prio & 0x0F);		/* 除16的余数，得到x坐标 */
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

    OSRdyGrp               |= ptcb->OSTCBBitY;         		/* 添加任务所在组到全局就绪组中 */
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
```

OSRdyGrp 是16位的，如果最大支持的任务为255个的话

OSRdyGrp 是8位的，如果最大支持的任务为63个的话

2. TCB就绪表中最高优先级**查找**过程中，任务就绪表(x,y)的计算方式

```c
#if OS_LOWEST_PRIO <= 63u                        /* 支持64个任务 */
    INT8U   y;
    
    y             = OSUnMapTbl[OSRdyGrp];		//查表法，获取最大优先级对应的OSRdyGrp序号
    OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
    //查表法，OSRdyGrp序号中的最高优先级数值  8*y + OSUnMapTbl[OSRdyTbl[y]]
    
#else                                            /* 支持256个任务 */
    INT8U     y;
    OS_PRIO  *ptbl;

    if ((OSRdyGrp & 0xFFu) != 0u) {		//后8位优先级比前8位更高(数值小)，所以先考虑后8位有没有就绪的任务
        y = OSUnMapTbl[OSRdyGrp & 0xFFu];
    } 
    else {
        y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
        //巧妙的利用同一个表进行计算，但是是从第8组开始计算的，所以有一个偏移值8
    }
    
    ptbl = &OSRdyTbl[y];
    
    //下，同理
    if ((*ptbl & 0xFFu) != 0u) {
        OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
    } 
    else {
        OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
    }
#endif
}
```

3. 当改变就绪状态后的，**注销**操作

```C
//os_time.c

{
    INT8U      y;
#if OS_CRITICAL_METHOD == 3u             /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0u;
#endif


    if (OSIntNesting > 0u) {                     /* 中断中无法调用该函数 */
        return;
    }
    if (OSLockNesting > 0u) {                    /* 调度器锁定时无法调用该函数*/
        return;
    }
    if (ticks > 0u) {                            /* 0 means no delay!  */
        OS_ENTER_CRITICAL();
        y            =  OSTCBCur->OSTCBY;        /* Delay current task   */
        OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;//从就绪表中注销
        if (OSRdyTbl[y] == 0u) {
            OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
        }
        OSTCBCur->OSTCBDly = ticks;              /* 记录等待时间 */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!  */
    }
}
```



### 如何使得任务控制块访问更加快速？

* 设置双向的单链表结构，实现任务TCB的遍历

* 通过设置一个OSPrioTbl数组，这样就不需要遍历整个任务控制链表来寻找某个优先级的任务了。
* 当前任务TCB是使用最为频繁的，随意特意给他一个全局指针变量



### 如何快速从就绪任务中选择需要运行的任务？

* 根据优先级顺序，建立一个全局任务就绪表OSRdyTbl
* 为方便就绪表的查找，建立一个全局就绪任务组OSRdyGrp
* 给每个TCB赋予了一个坐标X，Y的属性，可与OSRdyTbl，OSRdyGrp设定挂上钩
* 查找过程采用查表法，实现实时的操作系统

### Sem信号量的功能？

* 实现共享资源的多任务独享
* 实现任务1控制任务2的启动或者某项功能，即实现两个任务之间的协同工作

### 互斥信号量的功能？

* 和信号量一样实现资源的共享
* 最重要的一点是防止任务优先级的反转

### 任务优先级的反转是什么，怎么解决？

使用了最不消耗内存的方式解决了这个问题，将这个问题出现的前提条件破坏就行了。

前提条件：一个任务A占用互斥信号量，另一个比它优先级高的任务B等待。从而会导致优先级在AB之间的C，比B看上去优先级更高

### 信号量集的功能？

* 多个信号量的管理，实现复杂的功能
* 任务可以根据目前的信号集的不同状态实现不同的功能

### 动态分配内存的结构？

巧妙的采用了指针，实现内存链。很值得学习的代码片段

### 软件定时器的实现？

新建了一个时钟任务，用轮片法，实现了周期性唤醒某个回调函数的功能。是任务的一种巧妙的使用方法

# 6. 基本用户任务编写

用户任务与main地位等价。main()毕竟是一个应用程序的主函数，是程序运 行的入口点，所以虽然它不调用任务，但要负责任务的创建并将它们交给系统，至于何时运行它们，则与主函数无关。

```c
例3-1 —个用C语言编写的任务。
void MyTask(void * pdata) {	//与main地位等价
    for (;;)	
    {

            可以被中断的用户代码； 
            OS_ENTER_CRITICAL()； //进人临界段(关中断)
            不可以被中断的用户代码 
            OS_EXIT_CRITICAL()；  //退出临界段(开中断)
            可以被中断的用户代码；

    }
}

void main()
{
    OSInit()						  //初始化 uC/OS- II
    OSTaskCreate(MyTask1，······）；	//创建用户任务	1
    OSTaskCreate(MyTask2，······）；	//创建用户任务	2
    OSTaskCreate(MyTask3，······）；	//创建用户任务	3
    OSStart() ；						 //启动 uC/OS - II
}
```





# 参考资料

【1】嵌入式实时操作系统ucos-II 原理及应用  任哲编著